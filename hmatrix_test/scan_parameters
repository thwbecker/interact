#!/bin/bash
#
# scan parameters to find intersections
#
kstart=${1-.85}
kstop=${2-1.}
kinc=${3-0.001}
imode=${4-0}			# init mode

run=${5-1}			# 1: add 2: replace

tmpn=`mktemp`
trap "rm -f $tmpn*" EXIT

if [ $NR_CPUS -gt 64 ];then
    ncore=64
else
    ncore=$NR_CPUS
fi

lfile=px0log.dat


gawk -v k1=$kstart -v k2=$kstop -v ki=$kinc 'BEGIN{for(k=k1;k <= k2;k += ki)printf("%10.8f\n",k)}' | sort -g > $tmpn.knew
if [ -s $lfile ];then
    gawk -v i=$imode '{if($3==i)print($1)}' $lfile | sort -g > $tmpn.kold
    if [ `lc $tmpn.kold` -gt 0 ];then
	comm -23  $tmpn.knew $tmpn.kold > $tmpn.kcomp
    else
	cp $tmpn.knew $tmpn.kcomp
    fi
else
    cp $tmpn.knew $tmpn.kcomp
fi
if [ `lc $tmpn.kcomp` -gt 0 ];then
    kcomp=`cat $tmpn.kcomp`
    echo $0: detected those new ones to compute: $kcomp
    if [ $run -eq 2 ];then
	rm $lfile 2> /dev/null
	echo $0: replacing with $ks
    else
	echo $0: adding $ks
    fi
    j=0
    for k in $kcomp;do
	(find_intersect $k 1 $imode > tmp.k.$$.$k.dat )&
	if [ $j -ge $ncore ];then
	    wait
	    j=0
	fi
	((j=j+1))
    done
    wait
    cat tmp.k.$$.*.dat >> $lfile
    rm tmp.k.$$.*.dat 
    sort -g $lfile | uniq > tmp.dat ; mv tmp.dat $lfile
else
    echo $0: no new entries found
fi

